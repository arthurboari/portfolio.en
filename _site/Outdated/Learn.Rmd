---
title: "Learning R: base"
author: "Arthur Boari"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 4
    #code_folding: hide
---
O conteúdo desta página do blog é originado do curso [Learn ggplot2 in R for Data Visualization - 2021](https://www.udemy.com/course/learn-ggplot2-in-r-for-data-viz/).

# Comandos utéis

2022 | 01 | 10 Last compiled: `r Sys.Date()`

Nessa seção iremos compilar algumas funções úteis.

A primeira função é *dir*. Ela listará os arquivos presentes no nosso diretório de projeto ou a pasta. Veja o exemplo abaixo:

```{r diretório}
getwd() #essa função descreve o caminho do meu diretório de trabalho
dir() #aqui teremos a lista com os arquivos e pastas do diretório de trabalho
```

A segunda função é *ls*, que lista os objetos presentes no nosso ambiente global (Global Environment).
```{r ls}
ls() #essa função descreve os objetos presentes no Global Environment
objects() #mesma função que *ls()*
```

A terceira função é *remove*, e será útil para remover algum objeto do Global Environment.
```{r remove, echo=TRUE, message=TRUE, warning=TRUE}
#Vamos criar dois objetos
a<-1
b<-2
#Vamos listá-los
ls()
#Vamos remover o objeto *a*
remove(a)
#Vamos listá-los
objects()
#Vamos remover o objeto *b*
rm(b)
#Vamos listá-los
objects()
```

A quarta função é *print*, e como o nome sugere, irá imprimir no Console algum texto ou conteúdo de alguma variável. Veja o exemplo abaixo:
```{r print}
x<-"hello world!"
print(x)
#também podemos apenas chamar o objeto
x #irá retornar a mesma resposta
print("hello world") #outra forma
#como imprimir textos mais complexos?
cat("o valor da área do triângulo é", 135, "cm^2")
print(paste("o valor da área do triângulo é", 135, "cm^2"))
```

A quinta função é a *install.packages*, que instalará os pacotes no nosso R. O nome do pacote deve ser uma *string*, ou seja, texto!
```{r install.package, eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
install.packages("ggplot2")
```

A sexta função é *library*, que carregará o pacote instalado.
```{r library/require, echo=TRUE, message=TRUE, warning=TRUE}
library(ggplot2)
require(ggplot2)
```

A diferença entre *library* e *require* é que a segunda é a mais indicada pára implementação de funções que necessitam de funções de outros pacotes para operar.

# ESTRUTURAS NO R:

2022 | 01 | 10 Last compiled: `r Sys.Date()`

As estruturas do R podem ser classificadas quanto ao tipo de variável e quanto a estrutura utilizada.

* Quanto ao tipo de variável/classe:
  + Character (ou charactere/texto);
  + Numeric (numérico - seja discreto (integer, e.g. 1, 2,3) ou contínuo, e.g. 1.2,3.7,5.5);
  + Complex (números complexos, e.g. 2 + 5i);
  + Logical (lógicos ou booleanos, e.g. TRUE ou FALSE / 1 ou 0).

Note: o R entenderá sempre qualquer variável numérico como do tipo *double*, ou seja, tratará como discreto mesmo que não há informações sobre osa decimais. Para assimilar um número inteiro, utilize o caractere **L** após o número, como demonstrado abaixo. Para mais detalhes, leia o conteúdo desta [página](https://faculty.nps.edu/sebuttre/home/R/data.html).

```{r class/typeof/integer, echo=TRUE, message=TRUE, warning=TRUE}
x<-23L
print(x)
typeof(x) #verifica o tipo do objeto
class(x) #mesmo objetivo da função *typeof*
y<-23
print(y)
typeof(y)
class(y)
```

Observe que as duas formas produzem o mesmo resultado no console, mas a forma de armzenagem é diferente.

* Quanto ao tipo de estrutura:
 
  + Vector (vetor);
  + List (lista);
  + Matrix (matriz);
  + Array;
  + Dataframes.
  
# Vetores

2022 | 01 | 10 Last compiled: `r Sys.Date()`

Podem ser definidos como **uma coleção de elementos de uma mesma classe** e podem ser criados de duas maneiras:

## Através da função concatenar *c*

Essa função apenas irá propiciar a assimilação de mais de um valor por vez. Veja o exemplo abaixo:

```{r concatenar, eval=FALSE, include=TRUE}
?c #solicita o *help* da função
# Note que é a terceira letra do alfabeto na forma minúscula! O R é **case sensitive**, ou seja, *c* e *C* são completamente diferentes e isso vale para qualquer código aplicado ao R.
```
```{r cria vetor com concatenar}
x<-c(1,2,3,4,5,6,7,8,9,10)
print(x)
```

## Através da função *vector*

Essa função é ideal para quando se necessita de um vetor pré-criado vazio. Veja o exemplo abaixo:

```{r help função vector, eval=FALSE, include=TRUE}
?vector #solicita o *help* da função
```

```{r cria vetor vazio/vector, echo=TRUE}
y<-vector(mode = "numeric",length = 5)
print(y)
#podemos fazer operações com ele
y+1
y-1
```

### Funções úteis ao trabalhar com vetor:

#### Função *is.vector*

Essa função realiza a checagem do estrutura do objeto a partir da lógica. Observe:

```{r is.vector}
is.vector(y)
```

Com o resultado sendo **TRUE**, temos que sim, o objeto *y* é um vetor.

#### Função *as.vector*

Essa função serve para transformar uma estrutura em vetor.

```{r as.vector}
x <- c(a = 1, b = 2) # esse vetor tem as posições nomeadas
print(x)
# O objeto *x* é um vetor?
is.vector(x)
# Transforme o objeto *x* em um vetor
as.vector(x)
# Os objetos *x* e *as.vector(x)* são iguais?
all.equal(x, as.vector(x))
```

O resultado da última função nos diz que, embora o conteúdo dos vetores sejam iguais, eles se diferenciam quanto a nomeação dos valores.

## Acessando valores de um vetor

Para acessar qualquer valor de um vetor, usamos colchetes (chamamos de **indexação**). Veja o exemplo abaixo:

```{r criando e acessando vetor}
#Vamos criar o vetor
x<-1:10 #aqui os dois pontos significam até, ou seja, irá criar uma sequência de 1 a 10, um-a-um elemento
print(x)
#Vamos acessar o número 1: ele está na primeira posição do vetor, então:
x[1] # não existe posição 0 em vetores na linguagem R
#Para acessar o sexto elemento do vetor, usamos:
x[6]
#Acessando as posições 1 e 6 simultaneamente
x[c(1,6)]
#Acessando uma sequência de posições
x[8:10]
#Criando ouro vetor
y<-c("Arthur","Rezende","Boari")
print(y)
#Como o meu nome não tem "Rezende", vamos acessar o vetor *y* de forma que escreva o meu nome corretamente
y[c(T,F,T)]
#Modificando uma posição do vetor, suponhamos que *Rezende* se escreve com *s*
y[2]<-"Resende"
print(y)
```

Note: dentro dos conchetes esquevemos a **posição** que almejamos acessar, e não o valor que queremos. Podemos acessar através de um vetor lógico, também.

**COERÇÃO**: ocorre quando se misturam variáveis de diferentes classes em um mesmo objeto. Veja abaixo:

```{r coerção de vetores}
v<- c(1,TRUE) #aqui misturamos numérico com lógico
v # vemos que converteu TRUE em numérico
class(v)
v<-c(FALSE,"TRUE")
v # aqui ele converteu a character
class(v)
```

Veja que o R decidiu a classe do objeto e, por isso, tenha bastante cuidado ao trabalhar com vetores.

## Comparando vetores

Comparar vetores é de grande utilidade. Veremos como fazer isso:

```{r comparando vetores}
#Criando dois vetores
v1<-1:10
v2<-10:1
print(v1);print(v2)

#Podemos utilizar operadores matemáticos para realizar as comparações
v1 == v2 # os vetores são iguais?
v1 != v2 # os vetores são diferentes?
v1 > v2 # o vetor *v1* é maior que o vetor *v2*?
v1 < v2 # o vetor *v1* é menor que o vetor *v2*?

#Podemos utilizar a função *identical*
#Nesse caso, devemos garantir que *v1* e *v2* possuem a mesma classe
class(v1);class(v2)

#Como possuem a mesma classe, podemos usar a função:
identical(v1,v2)
```

## Operação com vetores

Utilizando os vetores *v1* e *v2* definidos acima, temos:

```{r operação com vetores de tamanhos iguais}
#soma
v1 + v2 
#subtração
v1 - v2 
#multiplicação
v1 * v2 
#divisão
v1/v2
```

Em alguns casos os vetores não terão o mesmo tamanho:

```{r  operação com vetores de tamanhos diferentes, message=TRUE, warning=TRUE}
#Verificando o tamanho dos vetores *v1* e *v2*
length(v1);length(v2)

#Criando vetores de tamanhos diferentes:
v1<-1:3
v2<-4:5
length(v1);length(v2)

#Vamos realizar apenas a soma dos vetores para ver como o R irá se comportar:
v1 + v2

# Para obter os valores acima tivemos:
  # 1 2 3 (v1)
  # 4 5 x (v2)
  # 5 7 7 (resultado)

#Para que o terceiro elemento da soma retorne 7, x deve ser igual a 4

#Podemos criar um vetor a partir da junção de dois
v<-c(v1,v2)
print(v)
```

Quando trabalhamos com vetores de tamanhos diferentes, os elementos do menor vetor serão repetidos até que os vetores tenham o mesmo tamanho. E esse comportamento é automático. Mais uma vez o R toma uma decisão por nós!

## Modificando um vetor

Para modificarmos um vetor, não necessitamos criá-lo novamente. Basta selecionar, através de indexação, o valor a ser alterado e assimilar o novo valor através do operador assimilação (<-).

```{r modificando um vetor}
# O vetor a ser modificado é o seguinte:
print(v)
typeof(v); class(v)
#Suponhamos que o valor '3' é, na verdade, 3.2.
#Alteramos assim:
v[3] # essa é a posição do valor 3
v[3]<-3.2
#Verificamos se a alteração ocorreu
print(v)
typeof(v); class(v)
```

## Ordenando um vetor numérico

Muitas vezes, organizar um vetor é importante para uma análise. Para isso, vamos criar um vetor numérico aleatório.

```{r ordenando um vetor numérico}
#Criando o vetor numérico aleatório
set.seed(126)
vetor<-c(6,4,2,1,0)
print(vetor)

#Função rank
rank(vetor)
#Essa função demonsta em qual posição de um vetor ordenado (crescente) cada posição do vetor original estaria
vetor[rank(vetor)] # verificando

#Função sort
sort(vetor) # já retorna o vetor ordenado

#Função order = rank
order(vetor)
vetor[order(vetor)]
```

# Lists

2022 | 01 | 11 Last compiled: `r Sys.Date()`

Esse tipo de objeto possibilita a inserção de vários tipos de elementos e estruturas dentro dele. Pode-se agrupar lists, vetores, dataframes, matrizes, etc.

Aqui não há coerção.

## Criando uma list: função *list()*

```{r função list, echo=FALSE,include=TRUE,eval=FALSE}
#Sempre recorra ao help das funções para aprender a usá-las
?list
```

```{r criando uma list}
#Nomeando os vetores
lista<-list(nomes = c("Arthur Boari","João da Silva"),
            idades = c(26,62),
            diabetes = c(F,T))
print(lista)

#Sem nomeação
lista2<-list(c("Arthur Boari","João da Silva"),
            c(26,62),
            c(F,T))
print(lista2)
```

Observe que inserimos três vetores: um de caracteres, um numérico e um lógico. Observe ainda que nomeamos cada um dos vetores.


## Acessando uma list via indexação por colchetes

Para o primeiro exemplo usaremos o objeto *lista2*:
```{r acessando list colchetes}
#Observando o objeto
print(lista2)

#Acessando um objeto da list
lista2[[2]] # o colchetes duplos é usado para acessar qualquer um dos objetos da list
class(lista2[[2]]) #numeric
class(lista2[2]) #list

#para acessar um dos valores de um dos elementos da list usamos um colchete simples após indexarmos o elemento que queremos:
lista2[[2]][2]
lista2[[2]][[2]] #essa forma é usada para uma list dentro da list (objeto)

#Inserindo uma list
lista2<-list(lista,list(c(25,74,26,47),c("Ana","Beatriz","Lúcia","Joana")))
print(lista2)

#Acessando a list (elemento)
lista2[[2]]
class(lista2[[2]]) #list

lista2[[2]][2]
class(lista2[[2]][2]) #list

lista2[[2]][[2]]
class(lista2[[2]][[2]]) #character
```
## Acessando uma list via indexação por cifrão

Para o exemplo usaremos o objeto *lista*:
```{r acessando list cifrão}
#Observando o objeto
print(lista)

#Acessando um objeto da list
lista$idades # o colchetes duplos é usado para acessar qualquer um dos objetos da list
class(lista$idades) #numeric
class(lista$idades[2]) #numeric

#para acessar um dos valores de um dos elementos da list usamos um colchete simples após indexarmos o elemento que queremos:
lista$idades[1]
```
## Atribuindo nomes

Usando a *lista2* modificada acima, vamos alterar/nomear os elementos dela.

```{r nomeando elementos da list}
print(lista2)
#Essa lista tem dois elementos agora
names(lista2)<-c("Grupo Experimento","Grupo Controle")
print(lista2)

#nomeando o segundo elemento
names(lista2[[2]])<-c("idade","nome")
print(lista2)

#acessando pelo nome
lista2[["Grupo Controle"]][["idade"]]
```

## Appending uma list

Agora nós queremos inserir um outro elemento na list. Acima mostramos uma forma de fazer, vamos repetir nessa seção.

```{r appendind a list}
print(lista2)

#criando um vetor de medicamentos
medicamento<-c("Azitromicina","Placebo","Viagra","Placebo")

#fazendo o appending
lista2$`Grupo Controle`[[length(lista2$`Grupo Controle`)+1]]<-medicamento

#alterando o nome
names(lista2$`Grupo Controle`)[3]<-"medicamentos"
print(lista2)
```

## Excluindo elementos de uma list

```{r excluindo elemento da list}
#Suponhamos que agora precisamos manter sigilo em relação ao nome dos participantes da pesquisa
print(lista2)

#Vamos removê-los então
lista2[[1]]$nomes<-NULL
lista2[[2]]$nome<-NULL

#checando se removeu
print(lista2)

#Agora os participantes estão mantidos sobre sigilo
```

## Concatenando lists

Aqui, o princípio é o mesmo de concatenar vetores.

```{r concatenando lists}
#Criando listas
lista3<-list(1:10)
lista4<-list(11:20)
lista5<-list(21:30)

#Concatenando
listaconcatenada<-c(lista3,lista4,lista5)
names(listaconcatenada)<-c("lista3","lista4","lista5")
print(listaconcatenada)
```

# Matrix

2022 | 01 | 12 Last compiled: `r Sys.Date()`

É um agrupamento de vetores, resultando em um objeto com dimensões.

## Criando uma matrix

Usamos a função *matrix*, como abaixo:

```{r criando matrix columnwise}
matrix(data = 1:25,
       nrow = 5,
       ncol = 5)
```
Observe que criamos uma matriz numérica através da sequência unitária de 1 a 25, explicitada no argumento *data*. Os argumentos *ncol* e *nrow*  definem o número de colunas e linhas, respectivamente, porém não necessita de definí-los conjuntamente, visto que o R irá completar as informações automaticamente.

É importante notar que o R preenche a matriz coluna-a-coluna (**columnwise**) - esse é o default, mas caso queiramos que preencha linha-a-linha, usamo o argumento *byrow*, como abaixo:

```{r criando matrix rowwise}
matrix(data = 1:25,
       nrow = 5,
       ncol = 5,
       byrow = TRUE)
```
Note: caso a definição dos valores dos argumentos *ncol* e *nrow* estejam em desacordo com o tamanho dos dados, alguns efeitos são esperados:

 * Valores inferiores ao tamanho dos dados:
   + Aqui você espera um corte nos dados até a dimensão informada nos argumentos da função *matrix*;
 * Valores superiores ao tamanho dos dados:
   + Aqui você espera uma réplica dos dados até a dimensão informada nos argumentos da função, ou seja, os espaços vazios serão preenchidos com o início dos dados até a última célula vazia disponível.
 
Veja um exemplo:

```{r ncol e nrow diferentes}
#Dimensões inferiores
matrix(data = 1:12,nrow = 4,ncol = 2)
#Dimensões superiores
matrix(data = 1:12,nrow = 4,ncol = 4)
```
## Alterando uma matrix

Assim como em uma list, matrix conseguem ter o nome das dimensões alteradas ou criadas juntamente na função *matrix*, veja abaixo:

```{r nomes matrix, message=TRUE, warning=TRUE}
#O argumento *dimnames* recebe uma list com vetores de carateres com os nomes das linhas e das colunas, nessa mesma ordem
matrix(data = 1:12,nrow = 4,ncol = 3,dimnames = list(rownames = c("r1","r2","r3","r4"),colnames = c("c1","c2","c3")))

matrix(data = 1:12,nrow = 4,ncol = 3,dimnames = list(c("r1","r2","r3","r4"),c("c1","c2","c3")))

#Podemos alterar após a criação
m<-matrix(data = 1:12,nrow = 4,ncol = 3)
print(m)
colnames(m)<-c("c1","c2","c3")
rownames(m)<-c("r1","r2","r3","r4")
```

## Acessando uma matrix

Utilizando a matrix armazenada no objeto *m*:

```{r acessando matrix}
#Como matrizes são vetores, podemos acessá-la dessa forma:
m[6]
m[2,2] # [linha,coluna]
m["r2","c2"]
m[2:4,2:3]
```

## Modificando uma matrix
### Transpondo uma matrix

Aqui, usamos a função *t*, de *transpose*:

```{r transpondo uma matrix}
print(m)
t(x = m)
```
### Adicionando linhas e colunas

Funções: *rbind* e *cbind*:

```{r cbind e rbind}
#CBIND
cbind(m, c(11,22,33,44))
#RBIND
rbind(m,c(11,22,33))
# Note: as alterações acima não estão gravadas no objeto *m*, pois não houve assimilação
```
```{r cbind e rbind again}
#CBIND
m<-cbind(m, c4 = c(11,22,33,44))
colnames(m)[4]<-"c4"
print(m)
#RBIND
m<-rbind(m,r5 = c(11,22,33))
print(m)
# Note: as alterações acima não estão gravadas no objeto *m*, pois não houve assimilação
```

### Alterando dimensões

Bom, matrizes não são mais do que vetores com dimensões.

```{r alterando dim()}
m<-matrix(data = 1:12,
          nrow = 4)
print(m)
dim(m) # 3 linhas e 3 colunas
dim(m)<-c(2,6) # esse código em uma matriz com nomes de colunas e linhas definidos irá resultar na perda desses nomes
print(m)
```

# Array

2022 | 01 | 12 Last compiled: `r Sys.Date()`

São elementos multidimensionais, ou seja, armazenam dados em mais de duas dimensões.

## Criando um array

```{r criando um array}
a<-array(data = 1:18,dim = c(3,3,2)) # c(x,y,z)
print(a)
```
Aqui nós temos duas matrizes retangulares justapostas.

## Acessando um array - indexação

```{r acessando um array}
# Acessando uma matrix
a[,,1] #matrix 1
a[,,2] #matrix 2

# Acessando um elemento de uma das matrizes
a[1,2,2] # [linha, coluna, matriz - eixo z]

# Acessando a primeira linha de todas as matrizes
a[1,,]

# Acessando a segunda coluna de todas as matrizes
a[,2,]
```
## Nomeando um array

Com a função *dimnames*, inserimos uma *list* com três vetores de caracteres: o primeiro para as linhas, o segundo para as colunas e o terceiro para as matrizes.

```{r nomeando um array}
dimnames(a)<-list(c("r1","r2","r3"),c("c1","c2","c3"),c("array 1","array 2"))
print(a)
```

# Dataframe

2022 | 01 | 14 Last compiled: `r Sys.Date()`

É um "tipo" de matrix - só que agora, cada vetor pode ser de um tipo, e.g. vetores numéricos, de caracteres, lógicos são permitidos em um mesmo objeto.

**Recorde:** objetos do tipo *matrix*, assim como vetores, permitem <u>apenas</u> um tipo de variável.

## Criando um dataframe