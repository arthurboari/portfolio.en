---
title: "Dicas"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 1
    #code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=TRUE)
```
Essa seção do [Arthur Learns R](https://arthurboari.github.io/ArthurLearnsR/index.html) apresenta algumas dicas de programação.

Aprender uma linguagem de programação pode aparecer assustador, mas <u>NÃO</u> é! Aproveito a home-page para deixar algumas dicas, mas primeiramente, por quê a linguagem R?

* A linguagem R, assim como o Python, é uma linguagem de <u>alto nível</u>. Isso significa que já existem funções prontas e que não haverá necessidade de você fazer longos *scripts* para *ensinar* o R como se faz uma média. Claro, que dependendo da área, você pode encontrar situações nas quais você precisará despender um bom tempo criando funções, caso não existam pacotes que contenham o que você almeja.

* Como citado anteriormente, o [CRAN](https://cran.r-project.org/) possui um vasto repositório com pacotes das mais diversas áreas, nas quais já existem funções programadas. Por exemplo, o pacote [*openair*](https://cran.r-project.org/web/packages/openair/) é destinado a área de poluição atmosférica, [*trend*](https://cran.r-project.org/web/packages/trend/) é um pacote para análise de tendências em séries históricas, e pacotes como o [*hydroGOF*](https://cran.r-project.org/web/packages/hydroGOF/) para análises hidrológicas.

* É uma das linguagens com bastante material acessível, sejam apostilas e livros em bookdown, sejam vídeos e tutoriais no YouTube, seja o fórum [*stackoverflow*](https://stackoverflow.com/questions/tagged/r), onde os usuários podem encontrar diversas dúvidas solucionadas. Apesar de ter uma versão em português deste fórum, a versão em inglês possui um banco mais vasto.

Esses são alguns benefícios, vamos a dicas:

* O aprendizado é <u>solitário</u>, mas não quer dizer que você não deva procurar ajuda (nos fóruns, vídeos e outras fontes).

* Procure deixar o seu *script* bem comentado (tudo o que vem após o jogo-da-velha é considerado comentário), com explicações:
 
    + do que está sendo feito;
    + do motivo de usar aquela função e para o quê ela serve;
    + os valores que argumentos assumem e se há alguma literatura científica que dê respaldo;
    + erros que você cometeu anteriormente.
    
* Pratique! Esse é o *segredo*. Tudo o que você precisar calcular, seja uma média ou algo bem simples, opte por fazer no R e não em programas de planilha eletrônica ou na calculadora do seu sistema operacional.

* Organização é a chave do negócio! Use projetos. Lá você poderá manter todos os arquivos o mais organizado possível. O próximo tópico aborda um tópico ("Caminho absoluto versus caminho relativo") bem interessante do porquê é melhor usar projetos.

# Caminho absoluto versus caminho relativo

2021 | 12 | 14 Last compiled: `r Sys.Date()`

Programar em R pode ser simples ou complicado de acordo com a preferência do cliente ;)

Brincadeiras a parte, trabalhar com análises no R vai despender de memória e vários arquivos (principalmente para importar os dados). Se você usa frequentemente as funções *getwd* e *setwd* para acessar pastas no seu computador, **PARE!**

O uso dessas funções irá, não só te deixar mal acostumado (pra não te ofender, te chamando de preguiçoso *emoji do riso*), mas <u>também</u> desorganizado. Para compreender o motivo, devemos entender dois conceitos básicos:

* **Caminho absoluto** é o caminho que qualquer arquivo tenha no diretório de seu computador, por exemplo: 
```{r caminho abs,echo=FALSE}
a<-"C:\\Users\\aboar\\Documents\\Pasta do R\\portAB\\_posts\\Caminho absoluto versus caminho relativo\\Caminho absoluto versus caminho relativo.Rmd"
print(a)
```

é o caminho do arquivo que gerou essa página. E é <u>característico</u> a presença do *C:*, *D:* ou *E:* a depender da sua máquina.

* **Caminho relativo** é o caminho que o arquivo tem dentro do projeto, o mesmo arquivo
citado através do caminho acima pode ser acessado assim: 

```{r imprime caminho,echo=FALSE}
b<-"_posts/Caminho absoluto versus caminho relativo/Caminho absoluto versus caminho relativo.Rmd"
print(b)
```

Perceba o seguinte: caso eu te entregue um script com a seguinte função: 

```{r importação + erro de caminho absoluto,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
dados<-read.csv("C:\Users\aboar\Documents\Pasta do R\portAB\_posts\Caminho absoluto versus caminho relativo\dados_tcc.csv")
```
O R irá encontrá-lo? Certamente **NÃO**! Por quê? Porque o uso desse caminho dentro da função *read.csv* é específico do <u>meu</u> computador. E agora?

O uso de projetos, e o seu compartilhamento através do GitHub ou através de outros serviços de armazenamentos em nuvem, permitem o acesso aos arquivos devido ao uso de caminhos relativos. Portanto, se eu compartilhasse com você o meu projeto, você conseguiria acessar o arquivo através do código:

```{r importação dados_tcc,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
dados<-read.csv("images/dados_tcc.csv.txt")
```

Em suma, trabalhe com projetos no R. Ali, todos os arquivos que você irá importar e todos os arquivos que você irá gerar, como *plots* e arquivos de dados já processados, poderão ser acessados facilmente depois através de caminhos relativos, além de permitir que outras pessoas vinculadas ao projeto possam executar o código em seus computadores próprios sem qualquer problema. Dica: aperte a tecla *tab* entre as aspas duplas do argumento *file* e selecione o arquivo pelo menu drop-down que irá abrir (benefícios do RStudio).


# Personalize o RStudio com um tema SEU!

2021 | 12 | 14 Last compiled: `r Sys.Date()`

Você, que utiliza a interface *RStudio* no dia-a-dia, já deve ter configurado a aparência do IDE (Ambiente de Desenvolvimento Integrado) para um tema que te agrade visualmente e não cause tanta fadiga ocular, certo? Eu já testei vários temas pré-definidos, e sempre havia algo que não me agradava, como cores "fracas" na parte de comentários, dentre outros pontos que não ficavam bem.

Nesse meu primeiro tutorial espero te guiar na construção de um tema **seu**! Vamos lá?

1. Primeiramente, abra este [link](https://tmtheme-editor.herokuapp.com/#!/editor/theme/Monokai). Aqui você encontrará o seguinte interface:

![Figura 1: Interface do endereço eletrônico](images\Temas RStudio\Site de temas.JPG)

* Na aba *Scopes* você pode alterar a cor da fonte (FG), a cor do fundo de cada uma das seções (BG) e se receberá itálico (*I*), negrito (**B**) ou sublinhado (<u>U</u>).

* Na aba *General* você irá definir o *background* do RStudio, e em *Info*
 você insere um nome e informações relacionadas ao seu tema.
 
* Quer inspiração? Abra o menu *drop-down* *Gallery* e você encontrará vários temas já pré-definidos e que não estão disponíveis no RStudio.

2. Após adaptar e criar o seu próprio tema, é hora de salvar o seu tema. Clique no menu **Download** e salve o arquivo .tmTheme em uma pasta destinada aos seus projetos do R.

Para este material, realizei o download do tema *Iceberg* disponível no menu *drop-down* *Gallery*.

3. Abra o seu RStudio e digite o seguinte código:

```{r convertTheme,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
rstudioapi::convertTheme("images\Temas RStudio\Iceberg.tmTheme")
```
Note: você deve ter o pacote **rstudioapi** instalado, caso contrário instale através do código:

```{r instalando rstudioapi package,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
install.packages("rstudioapi")
```

4. Agora cheque a aba *Appearance* do *Global Options*, localize o tema e clique em *Apply* para que seja aplicado a sua interface.

![Figura 2: Aba Appearance](images\Temas RStudio\Aba Appearance.JPG){width=50%}


Não deu certo? Pode entrar em contato através dos canais disponibilizados na aba **Sobre o autor** ou pesquise o erro no forum *stackoverflow*.

# Importando dados no R

2021 | 12 | 15 Last compiled: `r Sys.Date()`

Conforme você for aprofundando na trabalho com o R, vai acabar tendo de utilizar de bases de dados externas ao R, ou seja, com dados obtidos em portais e eles virão em vários formatos. Vamos aprender algumas funções e pacotes para que você importe o seu arquivo com êxito e não te traga dor de cabeça no futuro!

## Arquivo .csv

Esse tipo de arquivo vem da expressão "comma separated values", em um bom português: "valores separados por vírgula". Aqui a vírgula faz o papel do separador de colunas (veremos que o ponto-e-vírgula também pode fazer esse papel nos arquivos .csv).

O primeiro passo a lidar com esse tipo de arquivo é fazer sua **visualização** no Bloco de Notas. Você <u>NÃO</u> deve alterar o arquivo, apenas visualize e extraia informações que te ajudarão a importá-lo.

Como exemplo, irei utilizar um arquivo contendo dados de qualidade do ar para a estação Delegacia Amazonas (Belo Horizonte) de 2019.

A Figura abaixo exibe o arquivo aberto no Bloco de Notas.

![Figura 3: Arquivo aberto no Bloco de Notas](Arquivos\Importação\csv foto.JPG)

Aqui podemos denotrar que o arquivo possui cabeçalho, o ponto-e-vírgula separa as colunas  e a vírgula separa os decimais. São esses pontos que devem ser observados aqui.

Vamos para a primeira função. Essa é a *read.table* e é a *função-mãe* de outras como *read.csv* e *read.csv2*.

```{r eval=FALSE}
# dê um help na função e leia
?read.table

```


```{r importação de planilha2019}
#aqui está o script de importação e será explicado abaixo

dado<-read.table(file = "Arquivos/Importação/planilha2019.csv", header = TRUE,sep = ";",dec = ",")
```

O argumento **file** recebe, como *string*, o caminho no qual está o arquivo (<u>**note que é necessário adicionar a extensão do arquivo**</u> - você encontra na janela propriedades do arquivo). Ao trabalhar como projetos você pode simplesmente inserir as aspas duplas e teclar TAB para procurar de forma mais ágil o caminho do arquivo. **header** é um argumento lógico, que ao receber TRUE assume a <u>primeira linha</u> do arquivo como o cabeçalho, se receber FALSE a primeira linha será tratada como um dado normal. Os argumentos **sep** e **dec** recebem, como *string* os caracteres de separação de colunas e decimais, respectivamente.

Vamos observar o objeto **dado**:

```{r head de dado}
head(x = dado, n = 6)
```
Nota que *n* é o número de linhas do objeto que selecionei para visualizar.

Você pode utilizar a função **read.csv2** para importar o mesmo arquivo. Mas qual a diferença? Nenhuma! O que temos aqui é apenas a "definição de argumentos defaults". Veja:

```{r importação planilha + head}
dado<-read.csv2(file = "Arquivos/Importação/planilha2019.csv")
head(x = dado, n = 6)
```
Basicamente, o mesmo resultado. Portanto, há várias formas de importar o mesmo arquivo. Definir os argumentos ajuda a garantir uma importação mais detalhada. Você pode usar a função *read.table* para importar outros tipos de arquivos, como .txt.

## Planilhas do Excel

Aqui vamos precisar de pacote específico. Existem vários, entretanto iremos aprender a importar através de uma função do seguinte pacote:

```{r instalando readxl package,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
install.packages("readxl")
```

Aqui vamos trabalhar com um arquivo de dados meteorológicos de Lavras-MG.

```{r carregando readxl package e importando dados de LAVRAS}
#Carregando o pacote
library(readxl)

#importando
dado<-read_excel(path = "Arquivos/Importação/LAVRAS (83687) (2) (1).xlsx")
```

```{r eval=FALSE}
#help na função
?read_excel
```


Aqui bastou apenas definir o argumento *path* que é igual ao argumento *file* da função *read.table*.

Vamos visualizar parte do arquivo:

```{r head dos dados}
head(x = dado, n = 6)
```

Caso seu arquivo .csv ou .xlsx contenha linhas de texto antes do dado em sim, basta "pular" a quantidade de linhas através do argumento *skip* de suas respectivas funções.

Veja um aplicação do argumento *skip* abaixo:

```{r importação de dados de SOROCABA,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
dado<-read.csv2(file = "Arquivos/Importação/SOROCABA (83851).csv")

head(x = dado, n = 6)
```
> Error in read.table(file = file, header = header, sep = sep, quote = quote, : 
more columns than column names


Observe que ocorreu um erro. Basicamente ele "reclama" que há mais colunas do que nomes para ela. Vamos observar o arquivo no Bloco de Notas:

![Figura 4: Arquivo aberto no Bloco de Notas](Arquivos\Importação\csv foto 2.JPG)

Podemos ver que há uma linha antes do dados, vamos retirá-la com o argumento *skip*.

```{r importação de dados de SOROCABA 2}
dado<-read.csv2(file = "Arquivos/Importação/SOROCABA (83851).csv",skip = 1)

head(x = dado, n = 6)
```

Observe que agora deu certo!

Na próxima postagem veremos como exportar dados para .csv e .xlsx.

# Exportando dados no R

2021 | 12 | 16 Last compiled: `r Sys.Date()`

Agora que sabemos como se importam dados no R, é importante saber exportar. Para isso, vamos utilizar um dos *datasets* presentes no R.

Podemos verificar os datasets através do código:

```{r lista de datasets,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
library(help = "datasets")
```

Aqui iremos usar a matriz WorldPhones:

```{r help WorldPhones dataset,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
?WorldPhones

```

Esse *dataset* contém o número de telefones de várias partes do mundo, em milhões. Vamos visualizar antes de exportar:

```{r visualizar WorldPhones dataset}
WorldPhones
```

## Exportando em .csv

Aqui iremos utilizar a função *write.table*:

```{r help de write.table,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
?write.table
```

Habitue-se a ler os *helps* das funções <u>sempre</u> que for utilizar uma!

Vamos aprender:

```{r salvando em csv}
write.table(x = WorldPhones,file = "Arquivos/Exportação/WorldPhones.csv",sep = ";",dec = ",",row.names = FALSE)
```

O argumento *x* recebe o objeto que será exportado e *row.names* é um argumento que introduz o "nome" das linhas no arquivo exportado, acrescentando uma coluna ao mesmo. Os demais argumentos funcionam de forma análoga ao explicitado na seção de **Importação** acima.

Vamos ver o arquivo exportado:

![Figura 5: Arquivo aberto no Bloco de Notas](Arquivos\Exportação\csv.JPG)

Exportaremos o mesmo *dataset*, agora em .xlsx:

## Exportando em .xlsx

Para isso vamos utilizar o pacote:

```{r instalando openxlsx package,eval=FALSE, message=TRUE, warning=TRUE, include=TRUE}
install.packages("openxlsx")
```

Precisamos carregar o pacote:
```{r carregando openxlsx package}
library(openxlsx)
```

Vamos exportar:
```{r exportação em xlsx}
openxlsx::write.xlsx(x = as.data.frame(WorldPhones),file = "Arquivos/Exportação/WorldPhones.xlsx")
```

Note: convertemos *WorldPhones* em *dataframe*, pois o mesmo é uma *matrix* e a função aceita apenas um *dataframe* ou uma list no argumento *x*.

![Figura 6: Arquivo aberto no Bloco de Notas](Arquivos\Exportação\xlsx.JPG){width=70%}

Tivemos sucesso na exportação! Até o próximo tópico!!

# Deixe seu script prático

2022 | 3 | 20 Last compiled: `r Sys.Date()`

Trabalhar com R se torna uma tarefa um pouco mais fácil quando se usa *scripts*, porém pode virar um problema, caso você seja desorganizado. As dicas abaixo são compiladas do vídeo [10 Good Coding Practices for Data Science](https://www.youtube.com/watch?v=V5srYcnDowA).

**1) Defina o objetivo do código**

Antes de entrar no mérito desse tópico, leia o item [Caminho absoluto versus caminho relativo](https://arthurboari.github.io/ArthurLearnsR/Journal.html#Caminho_absoluto_versus_caminho_relativo) acima, veja que trabalhar com projetos no R irá facilitar a sua vida e já deixar os *scripts* organizados.

Mesmo que você não irá compartilhar o seu *script* com alguém, é sempre bom saber o que está sendo feito ali. Geralmente, após alguns dias sem ter contato com qualquer material, esquecemos o conteúdo dele. Portanto, mantenha tudo organizado.

Não tenha preguiça de usar vários *scripts* para uma análise em específico. Por exemplo, ao desenvolver um trabalho que envolva análise de dados de qualidade do ar, mantenha: *um script para cada estação, um script modelo com o passo-a-passo a ser realizado, um script para elaboração de mapas, um script para as análises de estatísticas, entre outros*.

Definir esse objetivo é importante, pois irá te guiar em relação ao que precisa ser feito. Faça um *brainstorming* dos passos a serem realizados, e começe a desenvolver o código"

**2) Minimizar o que (inevitavelmente) precisará de alteração**

Durante o desenvolvimento do código e das análises, os códigos podem mudar. Sejam dados a serem importados (e seus caminhos), sejam datas ou outros objetos.

**3) Trabalhar de cima para baixo, não para a direita**

Aqui, a sugestão é de escrever sequencialmente o código, de forma a executá-lo **de cima para baixo**, sem ficar **indo-e-voltando**. Mantenha uma lógica e evite escrever vários códigos em uma mesma linha, habitue-se a escrever verticalmente.

**4) Usar variável descritiva e nomes de funções**

Os objetos recebem nomes, e esses devem ser coerentes com o que está sendo realizado, de forma a ser facilmente detectado a motivação daquele código. Vamos supor a aplicação do teste de Mann-Kendall nos dados da estação MG.Aven.Cont (Avenida do Contorno):

```{r exemplo de nomes de objetos,echo=TRUE}
library(trend)
MG.Aven.Cont<-seq(from = 20, to = 300, by = 2) #dados sequenciais
MK.MG.Aven.Cont<-trend::mk.test(MG.Aven.Cont)
```

Atribua nomes simples e que tenham conteúdo!

**5) Utilizar funções em vez de repetir o código**

A depender do que está sendo realizado, há a necessidade de se repetir várias partes do código. Para simplificar, reduza-as em funções e poupe espaço no código! Poupe também tempo e saúde mental: caso precise alterar algo, fazê-lo na função irá poupá-lo de fazer ao longo do script.

**6) Mas não exagere com as funções de encadeamento**

Prefira criar funções simples e curtas ao invés de funções longas. Você pode se perder no emaranhado de código. Usar o operador **pipe** do pacote *dplyr* do *tidyverse* pode simplificar e melhorar a aparência e lógica do código.

```{r exemplo uso pipe,message=FALSE}
sqrt(log(max(c(5,4,9))))

# Com o operador pipe
library(dplyr)
c(5,4,9) %>%
  max()%>%
  log()%>%
  sqrt()
```
Sem o *pipe* você se perderia no monte de parênteses utilizados.

**7) Preste atenção aos tipos de dados**

Quando, ao executar um código, for gerado um erro, verifique se está sendo aplicado ao tipo certo de dado. Por exemplo, obter a média de um vetor de caracteres irá resultar em erro. Conhecer o tipo de dados que está trabalhando é de suma importância!

**8) Fornecer documentação e comentários adequados**

Sempre deixe comentários nos *scripts*. Nunca é demais deixar explícito o que está sendo feito nas linhas abaixo.

**9) Verificar os últimos e melhores pacotes para a tarefa**

Com o rápido desenvolvimento de pacotes em R, há chances de que as análises que você precisa fazer já estejam alocadas em um pacote específico. Faça buscas por eles, e não perca tempo tendo de programar tudo sendo que já existem funções para isso!

**10) Teste à medida que vai**

Não há outra forma, pratique e verifique o que funciona ou não.